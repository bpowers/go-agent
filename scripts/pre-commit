#!/bin/bash
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Determine where go install puts binaries
GOPATH=$(go env GOPATH)
GOBIN=$(go env GOBIN)
if [ -z "$GOBIN" ]; then
    BIN_DIR="$GOPATH/bin"
else
    BIN_DIR="$GOBIN"
fi

# Set tool paths
GOFUMPT="$BIN_DIR/gofumpt"
STATICCHECK="$BIN_DIR/staticcheck"

# Check for required tools
if [ ! -f "$GOFUMPT" ]; then
    echo -e "${RED}Error: gofumpt is not installed at $GOFUMPT${NC}"
    echo "Run './scripts/install-hooks.sh' to install required tools"
    exit 1
fi

if [ ! -f "$STATICCHECK" ]; then
    echo -e "${RED}Error: staticcheck is not installed at $STATICCHECK${NC}"
    echo "Run './scripts/install-hooks.sh' to install required tools"
    exit 1
fi

echo "The project passed all pre-commit checks before your changes. Any failing checks reported are the result of your changes and need to be fixed by addressing their root cause." >&2

echo "Running pre-commit checks..."

# 1. Check if gofumpt would make changes
echo -n "Checking code formatting with gofumpt... "
if ! "$GOFUMPT" -l . | grep -q .; then
    echo -e "${GREEN}✓${NC}"
else
    echo -e "${RED}✗${NC}"
    echo -e "${RED}The following files need formatting:${NC}"
    "$GOFUMPT" -l .
    echo -e "${YELLOW}Run '$GOFUMPT -w .' to fix formatting${NC}"
    exit 1
fi

# 2. Check if go generate would make changes
echo -n "Checking if go generate is up to date... "
# Save current state
TEMP_DIR=$(mktemp -d)
trap "rm -rf $TEMP_DIR" EXIT

# Find all generated files (typically have a comment like "Code generated")
find . -name "*.go" -exec grep -l "Code generated" {} \; > "$TEMP_DIR/generated_files.txt" || true

# Copy current generated files
while IFS= read -r file; do
    if [ -f "$file" ]; then
        mkdir -p "$TEMP_DIR/$(dirname "$file")"
        cp "$file" "$TEMP_DIR/$file"
    fi
done < "$TEMP_DIR/generated_files.txt"

# Run go generate
GENERATE_OUTPUT="$TEMP_DIR/generate_output.txt"
go generate ./... > "$GENERATE_OUTPUT" 2>&1

# Format any newly generated files
while IFS= read -r file; do
    if [ -f "$file" ]; then
        "$GOFUMPT" -w "$file"
    fi
done < "$TEMP_DIR/generated_files.txt"

# Check if any generated files changed
CHANGED=false
while IFS= read -r file; do
    if [ -f "$file" ] && [ -f "$TEMP_DIR/$file" ]; then
        if ! cmp -s "$file" "$TEMP_DIR/$file"; then
            CHANGED=true
            break
        fi
    elif [ -f "$file" ]; then
        # New generated file that didn't exist before
        CHANGED=true
        break
    fi
done < "$TEMP_DIR/generated_files.txt"

# Restore original files
while IFS= read -r file; do
    if [ -f "$TEMP_DIR/$file" ]; then
        cp "$TEMP_DIR/$file" "$file"
    fi
done < "$TEMP_DIR/generated_files.txt"

if [ "$CHANGED" = false ]; then
    echo -e "${GREEN}✓${NC}"
else
    echo -e "${RED}✗${NC}"
    echo -e "${RED}Generated files are out of date${NC}"
    # Display the go generate output to help debug
    if [ -s "$GENERATE_OUTPUT" ]; then
        cat "$GENERATE_OUTPUT"
    fi
    echo -e "${YELLOW}Run 'go generate ./... && $GOFUMPT -w .' to update generated files${NC}"
    exit 1
fi

# 3. Run staticcheck
echo -n "Running staticcheck... "
# Run staticcheck which detects SA2001 (empty critical sections) and SA2003 (deferred Lock instead of Unlock)
STATICCHECK_OUTPUT="$TEMP_DIR/staticcheck_output.txt"
if "$STATICCHECK" ./... > "$STATICCHECK_OUTPUT" 2>&1; then
    echo -e "${GREEN}✓${NC}"
else
    echo -e "${RED}✗${NC}"
    echo -e "${RED}Static analysis failed${NC}"
    # Display the captured output
    cat "$STATICCHECK_OUTPUT"
    echo -e "${YELLOW}Run '$STATICCHECK ./...' to see errors${NC}"
    exit 1
fi

# 4. Run tests with race detector
echo -n "Running tests with race detector... "
TEST_OUTPUT="$TEMP_DIR/test_output.txt"
if ./with_api_keys.sh go test -race ./... > "$TEST_OUTPUT" 2>&1; then
    echo -e "${GREEN}✓${NC}"
else
    echo -e "${RED}✗${NC}"
    echo -e "${RED}Tests failed${NC}"
    # Display the captured output
    cat "$TEST_OUTPUT"
    echo -e "${YELLOW}Run './with_api_keys.sh go test -race -shuffle on ./...' to see failures${NC}"
    exit 1
fi

# 5. Make sure no cheating happened with tests
# Set CLAUDE to the full path of claude if found on PATH, otherwise use local installation
if command -v claude > /dev/null 2>&1; then
    CLAUDE=$(command -v claude)
else
    CLAUDE="$HOME/.claude/local/claude"
fi

CLAUDE_SANITY_OUTPUT="$TEMP_DIR/claude_sanity_output.txt"
echo -n "Running claude to check that we don't have incomplete tests..."
./with_api_keys.sh "$CLAUDE" -p --allowedTools 'Bash(git:*)' LS Read --model sonnet "a user is looking to commit code - look at what parts of the diff being committed are in *_test.go files, and if any of the tests take shortcuts or are stubbed out (e.g. a comment to the effect of 'real logic to test this would go here'), start your response with 'FAIL: ' followed by a description of what is wrong, and what needs to happen.  Based on the test name and surrounding code, be clear on what test functionality is missing and needs to be implemented before it can be committed.  Strictly follow CLAUDE.md, provide guidance referencing CLAUDE.md, and tell the user to closely follow CLAUDE.md as they address the problem.  Also tell them they MUST NOT delete the tests, the only way to succeed on the task is to fully implement the test.  If the tests look reasonable you MUST respond succinctly with the 1-word message: SUCCESS" > "$CLAUDE_SANITY_OUTPUT" 2>&1

if grep -q "^SUCCESS$" "$CLAUDE_SANITY_OUTPUT"; then
    echo -e " ${GREEN}✓${NC}"
else
    echo -e " ${RED}✗${NC}"
    echo -e "${RED}Test quality check failed:${NC}"
    cat "$CLAUDE_SANITY_OUTPUT"
    exit 1
fi

echo -e "${GREEN}All pre-commit checks passed!${NC}"
